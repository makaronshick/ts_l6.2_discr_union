У вас є декілька типів дії:

   { type: 'CREATE_USER', payload: { name: string, age: number } }
   { type: 'DELETE_USER', payload: { userId: number } }
   { type: 'UPDATE_USER', payload: { userId: number, name?: string, age?: number } }
Створіть тип Action, який об'єднує ці три варіанти, використовуючи поле type як дискримінант.

Напишіть функцію handleAction, яка:

Приймає обʼєкт дії.

Виконує різну логіку залежно від значення action.type.

    Для CREATE_USER – виводить в консоль ім'я та вік нового користувача.
    Для DELETE_USER – виводить повідомлення, що користувач з таким userId видалений.
    Для UPDATE_USER – виводить, які дані оновлюються (ім’я, вік або обидва).
Переконайтеся, що при розгалуженні за action.type компілятор коректно звужує типи.

При зверненні до payload методів компілятор має гарантувати доступні поля залежно від дискримінанта.

Додайте нову дію, { type: 'BLOCK_USER', payload: { userId: number, reason: string } },

оновіть об'єднання Action і логіку у handleAction().

(Опційно!) Переконайтеся, що при появі нової дії ваша функція змусить вас розглянути її в switch,

та що, якщо ви не опрацюєте новий варіант, компілятор попередить про потенційну помилку

(наприклад, через `never` у дефолтному випадку).